{"version":3,"file":"BatchLogRecordProcessorBase.js","sourceRoot":"","sources":["../../../src/export/BatchLogRecordProcessorBase.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;GAcG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGH,OAAO,EAAE,IAAI,EAAE,MAAM,oBAAoB,CAAC;AAC1C,OAAO,EACL,gBAAgB,EAChB,MAAM,EACN,kBAAkB,EAClB,UAAU,EACV,cAAc,EACd,QAAQ,EACR,eAAe,GAChB,MAAM,qBAAqB,CAAC;AAO7B;IAYE,qCACmB,SAA4B,EAC7C,MAAU;;QADO,cAAS,GAAT,SAAS,CAAmB;QALvC,wBAAmB,GAAgB,EAAE,CAAC;QAQ5C,IAAM,GAAG,GAAG,MAAM,EAAE,CAAC;QACrB,IAAI,CAAC,mBAAmB;YACtB,MAAA,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,kBAAkB,mCAAI,GAAG,CAAC,+BAA+B,CAAC;QACpE,IAAI,CAAC,aAAa,GAAG,MAAA,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,YAAY,mCAAI,GAAG,CAAC,wBAAwB,CAAC;QAC1E,IAAI,CAAC,qBAAqB;YACxB,MAAA,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,oBAAoB,mCAAI,GAAG,CAAC,wBAAwB,CAAC;QAC/D,IAAI,CAAC,oBAAoB;YACvB,MAAA,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,mBAAmB,mCAAI,GAAG,CAAC,wBAAwB,CAAC;QAE9D,IAAI,CAAC,aAAa,GAAG,IAAI,cAAc,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;QAE9D,IAAI,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,aAAa,EAAE;YACjD,IAAI,CAAC,IAAI,CACP,wIAAwI,CACzI,CAAC;YACF,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,aAAa,CAAC;SAC/C;IACH,CAAC;IAEM,4CAAM,GAAb,UAAc,SAAoB;QAChC,IAAI,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE;YAC/B,OAAO;SACR;QACD,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;IAC/B,CAAC;IAEM,gDAAU,GAAjB;QACE,IAAI,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE;YAC/B,OAAO,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC;SACnC;QACD,OAAO,IAAI,CAAC,SAAS,EAAE,CAAC;IAC1B,CAAC;IAEM,8CAAQ,GAAf;QACE,OAAO,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC;IACnC,CAAC;IAEa,+CAAS,GAAvB;;;;;wBACE,IAAI,CAAC,UAAU,EAAE,CAAC;wBAClB,qBAAM,IAAI,CAAC,SAAS,EAAE,EAAA;;wBAAtB,SAAsB,CAAC;wBACvB,qBAAM,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,EAAA;;wBAA/B,SAA+B,CAAC;;;;;KACjC;IAED,qCAAqC;IAC7B,kDAAY,GAApB,UAAqB,SAAoB;QACvC,IAAI,IAAI,CAAC,mBAAmB,CAAC,MAAM,IAAI,IAAI,CAAC,aAAa,EAAE;YACzD,OAAO;SACR;QACD,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QACzC,IAAI,CAAC,gBAAgB,EAAE,CAAC;IAC1B,CAAC;IAED;;;;SAIK;IACG,+CAAS,GAAjB;QAAA,iBAeC;QAdC,OAAO,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YACjC,IAAM,QAAQ,GAAG,EAAE,CAAC;YACpB,IAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAC1B,KAAI,CAAC,mBAAmB,CAAC,MAAM,GAAG,KAAI,CAAC,mBAAmB,CAC3D,CAAC;YACF,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,CAAC,EAAE,EAAE;gBACnC,QAAQ,CAAC,IAAI,CAAC,KAAI,CAAC,cAAc,EAAE,CAAC,CAAC;aACtC;YACD,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC;iBAClB,IAAI,CAAC;gBACJ,OAAO,EAAE,CAAC;YACZ,CAAC,CAAC;iBACD,KAAK,CAAC,MAAM,CAAC,CAAC;QACnB,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,oDAAc,GAAtB;QAAA,iBAeC;QAdC,IAAI,CAAC,WAAW,EAAE,CAAC;QACnB,IAAI,IAAI,CAAC,mBAAmB,CAAC,MAAM,KAAK,CAAC,EAAE;YACzC,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;SAC1B;QACD,OAAO,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YACjC,eAAe,CACb,KAAI,CAAC,OAAO,CACV,KAAI,CAAC,mBAAmB,CAAC,MAAM,CAAC,CAAC,EAAE,KAAI,CAAC,mBAAmB,CAAC,CAC7D,EACD,KAAI,CAAC,oBAAoB,CAC1B;iBACE,IAAI,CAAC,cAAM,OAAA,OAAO,EAAE,EAAT,CAAS,CAAC;iBACrB,KAAK,CAAC,MAAM,CAAC,CAAC;QACnB,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,sDAAgB,GAAxB;QAAA,iBAiBC;QAhBC,IAAI,IAAI,CAAC,MAAM,KAAK,SAAS,EAAE;YAC7B,OAAO;SACR;QACD,IAAI,CAAC,MAAM,GAAG,UAAU,CAAC;YACvB,KAAI,CAAC,cAAc,EAAE;iBAClB,IAAI,CAAC;gBACJ,IAAI,KAAI,CAAC,mBAAmB,CAAC,MAAM,GAAG,CAAC,EAAE;oBACvC,KAAI,CAAC,WAAW,EAAE,CAAC;oBACnB,KAAI,CAAC,gBAAgB,EAAE,CAAC;iBACzB;YACH,CAAC,CAAC;iBACD,KAAK,CAAC,UAAA,CAAC;gBACN,kBAAkB,CAAC,CAAC,CAAC,CAAC;YACxB,CAAC,CAAC,CAAC;QACP,CAAC,EAAE,IAAI,CAAC,qBAAqB,CAAC,CAAC;QAC/B,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAC1B,CAAC;IAEO,iDAAW,GAAnB;QACE,IAAI,IAAI,CAAC,MAAM,KAAK,SAAS,EAAE;YAC7B,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAC1B,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC;SACzB;IACH,CAAC;IAEO,6CAAO,GAAf,UAAgB,UAAuB;QAAvC,iBA4BC;QA3BC,IAAM,QAAQ,GAAG;YACf,OAAA,QAAQ;iBACL,OAAO,CAAC,KAAI,CAAC,SAAS,EAAE,UAAU,CAAC;iBACnC,IAAI,CAAC,UAAC,MAAoB;;gBACzB,IAAI,MAAM,CAAC,IAAI,KAAK,gBAAgB,CAAC,OAAO,EAAE;oBAC5C,kBAAkB,CAChB,MAAA,MAAM,CAAC,KAAK,mCACV,IAAI,KAAK,CACP,+DAA6D,MAAM,MAAG,CACvE,CACJ,CAAC;iBACH;YACH,CAAC,CAAC;iBACD,KAAK,CAAC,kBAAkB,CAAC;QAZ5B,CAY4B,CAAC;QAE/B,IAAM,gBAAgB,GAAG,UAAU;aAChC,GAAG,CAAC,UAAA,SAAS,IAAI,OAAA,SAAS,CAAC,QAAQ,EAAlB,CAAkB,CAAC;aACpC,MAAM,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,sBAAsB,EAA/B,CAA+B,CAAC,CAAC;QAEvD,sFAAsF;QACtF,IAAI,gBAAgB,CAAC,MAAM,KAAK,CAAC,EAAE;YACjC,OAAO,QAAQ,EAAE,CAAC;SACnB;aAAM;YACL,OAAO,OAAO,CAAC,GAAG,CAChB,gBAAgB,CAAC,GAAG,CAAC,UAAA,QAAQ,YAAI,OAAA,MAAA,QAAQ,CAAC,sBAAsB,+CAA/B,QAAQ,CAA2B,CAAA,EAAA,CAAC,CACtE,CAAC,IAAI,CAAC,QAAQ,EAAE,kBAAkB,CAAC,CAAC;SACtC;IACH,CAAC;IAGH,kCAAC;AAAD,CAAC,AApKD,IAoKC","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { ExportResult } from '@opentelemetry/core';\nimport { diag } from '@opentelemetry/api';\nimport {\n  ExportResultCode,\n  getEnv,\n  globalErrorHandler,\n  unrefTimer,\n  BindOnceFuture,\n  internal,\n  callWithTimeout,\n} from '@opentelemetry/core';\n\nimport type { BufferConfig } from '../types';\nimport type { LogRecord } from '../LogRecord';\nimport type { LogRecordExporter } from './LogRecordExporter';\nimport type { LogRecordProcessor } from '../LogRecordProcessor';\n\nexport abstract class BatchLogRecordProcessorBase<T extends BufferConfig>\n  implements LogRecordProcessor\n{\n  private readonly _maxExportBatchSize: number;\n  private readonly _maxQueueSize: number;\n  private readonly _scheduledDelayMillis: number;\n  private readonly _exportTimeoutMillis: number;\n\n  private _finishedLogRecords: LogRecord[] = [];\n  private _timer: NodeJS.Timeout | undefined;\n  private _shutdownOnce: BindOnceFuture<void>;\n\n  constructor(\n    private readonly _exporter: LogRecordExporter,\n    config?: T\n  ) {\n    const env = getEnv();\n    this._maxExportBatchSize =\n      config?.maxExportBatchSize ?? env.OTEL_BLRP_MAX_EXPORT_BATCH_SIZE;\n    this._maxQueueSize = config?.maxQueueSize ?? env.OTEL_BLRP_MAX_QUEUE_SIZE;\n    this._scheduledDelayMillis =\n      config?.scheduledDelayMillis ?? env.OTEL_BLRP_SCHEDULE_DELAY;\n    this._exportTimeoutMillis =\n      config?.exportTimeoutMillis ?? env.OTEL_BLRP_EXPORT_TIMEOUT;\n\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n\n    if (this._maxExportBatchSize > this._maxQueueSize) {\n      diag.warn(\n        'BatchLogRecordProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize'\n      );\n      this._maxExportBatchSize = this._maxQueueSize;\n    }\n  }\n\n  public onEmit(logRecord: LogRecord): void {\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n    this._addToBuffer(logRecord);\n  }\n\n  public forceFlush(): Promise<void> {\n    if (this._shutdownOnce.isCalled) {\n      return this._shutdownOnce.promise;\n    }\n    return this._flushAll();\n  }\n\n  public shutdown(): Promise<void> {\n    return this._shutdownOnce.call();\n  }\n\n  private async _shutdown(): Promise<void> {\n    this.onShutdown();\n    await this._flushAll();\n    await this._exporter.shutdown();\n  }\n\n  /** Add a LogRecord in the buffer. */\n  private _addToBuffer(logRecord: LogRecord) {\n    if (this._finishedLogRecords.length >= this._maxQueueSize) {\n      return;\n    }\n    this._finishedLogRecords.push(logRecord);\n    this._maybeStartTimer();\n  }\n\n  /**\n   * Send all LogRecords to the exporter respecting the batch size limit\n   * This function is used only on forceFlush or shutdown,\n   * for all other cases _flush should be used\n   * */\n  private _flushAll(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const promises = [];\n      const batchCount = Math.ceil(\n        this._finishedLogRecords.length / this._maxExportBatchSize\n      );\n      for (let i = 0; i < batchCount; i++) {\n        promises.push(this._flushOneBatch());\n      }\n      Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(reject);\n    });\n  }\n\n  private _flushOneBatch(): Promise<void> {\n    this._clearTimer();\n    if (this._finishedLogRecords.length === 0) {\n      return Promise.resolve();\n    }\n    return new Promise((resolve, reject) => {\n      callWithTimeout(\n        this._export(\n          this._finishedLogRecords.splice(0, this._maxExportBatchSize)\n        ),\n        this._exportTimeoutMillis\n      )\n        .then(() => resolve())\n        .catch(reject);\n    });\n  }\n\n  private _maybeStartTimer() {\n    if (this._timer !== undefined) {\n      return;\n    }\n    this._timer = setTimeout(() => {\n      this._flushOneBatch()\n        .then(() => {\n          if (this._finishedLogRecords.length > 0) {\n            this._clearTimer();\n            this._maybeStartTimer();\n          }\n        })\n        .catch(e => {\n          globalErrorHandler(e);\n        });\n    }, this._scheduledDelayMillis);\n    unrefTimer(this._timer);\n  }\n\n  private _clearTimer() {\n    if (this._timer !== undefined) {\n      clearTimeout(this._timer);\n      this._timer = undefined;\n    }\n  }\n\n  private _export(logRecords: LogRecord[]): Promise<void> {\n    const doExport = () =>\n      internal\n        ._export(this._exporter, logRecords)\n        .then((result: ExportResult) => {\n          if (result.code !== ExportResultCode.SUCCESS) {\n            globalErrorHandler(\n              result.error ??\n                new Error(\n                  `BatchLogRecordProcessor: log record export failed (status ${result})`\n                )\n            );\n          }\n        })\n        .catch(globalErrorHandler);\n\n    const pendingResources = logRecords\n      .map(logRecord => logRecord.resource)\n      .filter(resource => resource.asyncAttributesPending);\n\n    // Avoid scheduling a promise to make the behavior more predictable and easier to test\n    if (pendingResources.length === 0) {\n      return doExport();\n    } else {\n      return Promise.all(\n        pendingResources.map(resource => resource.waitForAsyncAttributes?.())\n      ).then(doExport, globalErrorHandler);\n    }\n  }\n\n  protected abstract onShutdown(): void;\n}\n"]}